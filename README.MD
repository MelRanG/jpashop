# 1일차
- Setter는 닫자. Setter를 열어두면 나중에 엔티티가 변경됐을 때 어디서 변경됐는지 찾기 어렵다. -> 변경이 필요한 경우 setPassword메소드 말고 changePassword처럼 필요한 메소드를 만들어서 사용하자. -> 그럼 메소드 이름만 바꾸는데 무슨 차이가 있지?
  - 찾아보니 여러 차이가 있다.
    1. 메소드의 의도를 명확하게 한다. setPassword만 적어놓으면 update인지 create인지 구분할 수 없다. 코드가 비대해지면 메소드명만 봐도 어떤 동작을 하는지 예측가능해야한다.
    2. 1번을 해결함으로써 협업에 이점이 있다. 다른사람이 내 코드를 보거나, 시간이 지난 뒤 내가 내 코드를 봤을 때 빠르게 이해할 수 있다.
- 상속 관계 테이블인 경우 Inheritance 어노테이션을 붙여야 한다. strategy = InheritanceType으로 3가지가 있고 상황에 맞게 사용한다.
- ManyToMany를 쓰면 안되는 이유는 중간 테이블이 자동으로 생성되고 이 테이블에 값을 넣고, 수정할 수 없다. -> 운영이 어렵다.
- 사용하는 곳에선 DiscriminatorColumn을 붙여서 구분할 칼럼을 넣어줘야한다.
- enum타입은 String을 사용하자. ordinal타입은 숫자로 들어가는데 중간에 값이 추가가 되면 숫자가 맞지 않는다.
- 값 타입(Adress)의 경우 Setter를 닫고 기본생성자는 외부에서 못건드리게 protected로 선언해놓자. JPA에서 리플랙션을 사용해야해서 private으로는 못쓴다.
# 2일차
- 모든 연관관계는 지연로딩으로 하자. 즉시로딩은 조인할 때 해당하는 테이블을 즉시 로딩한다. 여러개가 연관돼있으면 하나 가져오면 다 로딩한다.
- 만약 연관된 엔티티를 함께 DB에서 조회해야하면, fet join이나 엔티티 그래프를 사용. 특히 Eager를 쓰고 JPQL을 사용하면 문제가 발생한다. XToOne은 기본이 Eager니 주의
- 엔티티 내 collection은 바로 초기화하고 추가로 건드리지 말자. em에서 영속화(db에 삽입)하면 hibernate가 collection을 감싸는데 이 때 건드린다면 의도치 않게 동작할 수 있다.  
- 칼럼명에 대문자가 있거나 온점이 있다면 SpringBoot의 SpringPhysicalNamingStrategy에서 언더스코어로 알아서 바꿔준다.
- cascade = CascadeType.ALL을 선언하면 엔티티를 저장,삭제하면 cascade 대상 엔티티도 자동으로 저장,삭제된다. -> A안에 B가 있을 때 A를 저장할 때 B객체를 만들어 저장하면 따로 B.save하지 않아도 B가 자동저장됨