# 1일차
- Setter는 닫자. Setter를 열어두면 나중에 엔티티가 변경됐을 때 어디서 변경됐는지 찾기 어렵다. -> 변경이 필요한 경우 setPassword메소드 말고 changePassword처럼 필요한 메소드를 만들어서 사용하자. -> 그럼 메소드 이름만 바꾸는데 무슨 차이가 있지?
  - 찾아보니 여러 차이가 있다.
    1. 메소드의 의도를 명확하게 한다. setPassword만 적어놓으면 update인지 create인지 구분할 수 없다. 코드가 비대해지면 메소드명만 봐도 어떤 동작을 하는지 예측가능해야한다.
    2. 1번을 해결함으로써 협업에 이점이 있다. 다른사람이 내 코드를 보거나, 시간이 지난 뒤 내가 내 코드를 봤을 때 빠르게 이해할 수 있다.
- 상속 관계 테이블인 경우 Inheritance 어노테이션을 붙여야 한다. strategy = InheritanceType으로 3가지가 있고 상황에 맞게 사용한다.
- ManyToMany를 쓰면 안되는 이유는 중간 테이블이 자동으로 생성되고 이 테이블에 값을 넣고, 수정할 수 없다. -> 운영이 어렵다.
- 사용하는 곳에선 DiscriminatorColumn을 붙여서 구분할 칼럼을 넣어줘야한다.
- enum타입은 String을 사용하자. ordinal타입은 숫자로 들어가는데 중간에 값이 추가가 되면 숫자가 맞지 않는다.
- 값 타입(Adress)의 경우 Setter를 닫고 기본생성자는 외부에서 못건드리게 protected로 선언해놓자. JPA에서 리플랙션을 사용해야해서 private으로는 못쓴다.
# 2일차
- 모든 연관관계는 지연로딩으로 하자. 즉시로딩은 조인할 때 해당하는 테이블을 즉시 로딩한다. 여러개가 연관돼있으면 하나 가져오면 다 로딩한다.
- 만약 연관된 엔티티를 함께 DB에서 조회해야하면, fet join이나 엔티티 그래프를 사용. 특히 Eager를 쓰고 JPQL을 사용하면 문제가 발생한다. XToOne은 기본이 Eager니 주의
- 엔티티 내 collection은 바로 초기화하고 추가로 건드리지 말자. em에서 영속화(db에 삽입)하면 hibernate가 collection을 감싸는데 이 때 건드린다면 의도치 않게 동작할 수 있다.  
- 칼럼명에 대문자가 있거나 온점이 있다면 SpringBoot의 SpringPhysicalNamingStrategy에서 언더스코어로 알아서 바꿔준다.
- cascade = CascadeType.ALL을 선언하면 엔티티를 저장,삭제하면 cascade 대상 엔티티도 자동으로 저장,삭제된다. -> A안에 B가 있을 때 A를 저장할 때 B객체를 만들어 저장하면 따로 B.save하지 않아도 B가 자동저장됨

# 3일차
- save테스트할 때 JPA는 insert쿼리를 수행하지 않는다. JPA가 영속성 컨테스트에 커밋하기 전에 Spring에서 트랜잭션 롤백을 수행하기 때문임. insert쿼리르 보고싶다면 em.flush()를 수행하거나 롤백을 막아야함.
- 테스트할 때 서버에 작은 메모리DB도 같이 올려서 테스트하면 편하다.
- 테스트는 별도의 yml파일로 설정해서 사용해야한다. 테스트에서 DB를 사용할 때 메모리모드로 사용해야하며(h2:mem:test) 스프링부트는 테스트 yml에 메모리모드로 설정하지 않아도 알아서 해준다.
- CasecadeTpe.ALL로 order를 저장하면 나머지 delivery, orderitem도 저장된다. casecade는 신중하게 써야하는데 delivery처럼 한 곳에서만 쓰이는 경우 사용해도 된다.
- Service는 여러 로직이 종합적으로 있고 도메인에는 개별로직이 존재한다. 중요한 개별로직의 경우 따로 테스트를 진행하고 서비스에서는 여러 도메인 로직이 잘 수행되는지 통합적으로 테스트한다. ex)재고감소는 중요한 로직이니 별도로 또 테스트

# 4일차
- 동적쿼리란 조건에 따라 실행이 달라지는 쿼리다. 검색할 때 내용이 없으면 전체를 출력하고 내용이 있으면 where절에 조건을 추가해서 검색하는 것처럼 상황에 따라 바뀌는 쿼리는 의미한다.
- 이러한 동적 쿼리를 쉽게 처리하려면 QueryDSL을 사용한다.
- 상품 수정에서 id를 넘길 때 반드시 해당 유저가 그 아이템을 수정할 수 있는지 확인해야한다. 보통 Service단에서 확인한다.
# 5일차
- 준영속 엔티티란 영속성 컨텍스트가 더 이상 관리하지 않는 엔티티이며, DB에 한번 저장돼서 식별자가 생성된 엔티티를 의미한다.
- 영속성 엔티티는 값을 바꾸고 save하지 않더라도 알아서 업데이트 되지만 준영속엔티티는 별도로 저장해야한다.
- 수정에는 변경감지와 merge가 있다.
  - 변경감지는 수정할 내용이 담긴 객체(준영속성 컨텍스트)를 받고 findOne으로 DB에서 대상 객체를 꺼내온다. 꺼내온 객체는 영속성 컨텍스트에 등록된 것이다. 해당 객체에 수정할 객체를 다 주입하면 따로 SAVE하지 않아도 JPA에서 flush가 수행될 때 변경이력을 찾아서 수정해준다.
  - 머지는 위 과장을 코드 한줄로 처리한 것.
  - 다만 머지에 넣은 item은 영속성 컨텍스트로 바뀌지 않아서 반드시 merge로 반환된 값을 사용해야 한다. 또한 병합을 사용하면 모든 속성이 다 바뀐다. 없는 값은 null로 업데이트됨
  - 실무에선 실수할 수 있기 때문에 변경감지를 사용하자.
  - update를 할 때 set으로 넣지말고 의미있는 메소드에 값을 넣고 도메인에서 수정하자. chage, add이런식으로
- 컨트롤러에서 id를 받아서 findOne으로 엔티티를 조회한 뒤 Service로 넘기기 vs 컨트롤러에서 id를 받아서 바로 서비스로 넘겨서 서비스에서 조회하기
  - @Transactional이 유지된 상태에서 작업하면 영속성 컨텍스트가 유지된다. 전자는 영속성 컨텍스트가 유지되지 않고 후자는 유지되므로 수정이 발생할 때 후자가 유리하다.
  - @ModelAttrinute로 값을 받으면 model에 자동으로 추가돼있어서 addAttribute를 사용하지 않아도 된다.